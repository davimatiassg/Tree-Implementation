<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trabalho de EDB2</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#implementação-da-árvore">Implementação da Árvore</a></li>
<li><a href="#análise-dos-algoritmos">Análise dos Algoritmos</a>
<ul>
<li><a href="#algoritmos-da-implementação-básica">1. Algoritmos da Implementação Básica</a></li>
<li><a href="#algoritmos-requisitados">2. Algoritmos requisitados</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      
<h1 id="implementação-da-árvore">Implementação da Árvore</h1>
<p>A árvore binária de busca foi implementada utilizando apenas uma classe (BinaryTree). A classe possui um argumento de tipo genérico T, onde T é uma classe que herda da classe Comparable. Isso é importante por que é através dessa classe que poderemos realizar comparações entre os elementos da árvore (através do método T1.compareTo(T2), que retorna -1 caso T1 &lt; T2, 0 caso T1 = T2 e 1 caso T1 &gt; T2). Para a execução do código apresentado neste trabalho, usaremos a classe <em>Integer</em> no lugar do argumento T.</p>
<p>Cada nó da árvore, representado por um objeto da classe <em>BinaryTree</em> possui 7 atributos, todos de aceso restrito ao pacote <em>tree</em> (que apenas contém a classe BinaryTree, até o momento de escrita deste documento). Estes são:</p>
<p>T <strong>value</strong>: O valor armazenado nó da árvore.</p>
<p>int <strong>height</strong>: Um inteiro maior que 1 que representa a altura do nó, em comparação com o seu “galho” mais distante.</p>
<p>int <strong>leftNodes</strong> e <strong>rightNodes</strong>: Inteiros positivos que respectivamente representam o número de nós nas subárvores esquerda e direita deste nó.</p>
<p>BinaryTree <strong>root</strong>: O nó raiz (ou a árvore pai) desta instância da BinaryTree. Caso não seja especificado um valor para a raiz de uma BinaryTree, essa referência é assinalada para a própria instância (ou seja, a instância é a própria raiz).</p>
<p>BinaryTree <strong>leftTree</strong> e <strong>rightTree</strong>: Referências para as árvores esquerda e direita desta instância da BinaryTree. Essas referências permanecem com os valores <em>null</em> caso não hajam subárvores para esse nó.</p>
<p>Atestamos que a implementação da árvore binária não é responsável por lidar com erros de uso, tais como tentativas de busca com argumentos nulos ou inválidos.</p>
<h1 id="análise-dos-algoritmos">Análise dos Algoritmos</h1>
<p>Agora, descreveremos o processe de execução de cada um dos algoritmos implementados na classe <em>BinaryTree</em>. Para tal, considere uma árvore binária com <em>n</em> nós.</p>
<h2 id="algoritmos-da-implementação-básica">1. Algoritmos da Implementação Básica</h2>
<p>Apresentaremos aqui alguns dos algoritmos básicos que devem estar presentes na estrutura de uma árvore, mesmo que não estivessem sendo explicitamente requisitados na especificação.</p>
<h3 id="busca-na-árvore-searcht-value">1.1. Busca na árvore: <code>search(T value)</code></h3>
<hr>
<p>O algoritmo de busca de uma árvore binária é provavelmente uma das partes mais vantajosas desse tipo de implementação. O método <code>search(T value)</code>, chamado através da referência de um objeto <em>BinaryTree</em>, é responsável por realizar a busca por determinado valor em alguma das suas subárvores. O algoritmo procede de maneira recursiva, como visto a seguir:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">search</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span>
</span><span class="codeline">	<span class="token punctuation">{</span>
</span><span class="codeline">	<span class="token keyword">int</span> comparison <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">	BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> nextTree <span class="token operator">=</span> comparison <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> leftTree <span class="token operator">:</span> rightTree<span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>comparison <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>nextTree <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token keyword">return</span> nextTree<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline"><span class="token punctuation">}</span></span>
</code></pre>
<p>A execução do algoritmo segue um fluxo simples. Compara-se o valor pesquisado com o valor do nó atual para decidir a direção em que a recursão do algoritmo deve acontecer e, em seguida, verifica-se se alguma das condições de parada foi atingida, dando sequência à recursão no caso contrário.</p>
<p>Para a análise da complexidade assintótica, consideremos uma árvore binária de tamanho n. Note que a complexidade desse algoritmo depende da configuração da árvore. O pior caso dessa recursão se dá quando a busca acontece numa árvore cujos nós possuem exatamente um nó filho. Para tal configuração, o algorítmo é <em>O(n)</em>, uma vez que todos os nós precisam ser comparados. No caso preferível da árvore ser completa, a complexidade T(n) de cada chamada recursiva pode ser obtida por <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">T(n) = T(\frac{n}{2}) + 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span>
</span><span class="base"><span class="strut" style="height: 1.095em; vertical-align: -0.345em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span>
</span></span>
</span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span>
</span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span>
</span></span>
</span></span><span class="vlist-s">​</span>
</span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span>
</span></span>
</span></span><span class="mclose nulldelimiter"></span>
</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span>
</span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span>
</span></span>
</span></span>. Pelo segundo caso do teorema mestre, portanto, temos <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(T(n)) = O(lg(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span>
</span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span>
</span></span>
</span></span>.</p>
<h3 id="inserção-na-árvore-addvalue-t">1.2. Inserção na árvore: <code>add(value T)</code></h3>
<hr>
<p>Abrindo mão do uso do método <code>search</code> para buscar pelo nó externo onde o elemento desejado pode ser inserido na árvore, o método <code>add(T value)</code> possui algumas peculiaridades mais complexas. Como visível abaixo, o algoritmo também segue um processe recursivo, que percorre a árvore apenas uma vez e, com base no retorno do método (um booleano que indica se foi possível inserir o elemento desejado), realiza a atualização da altura do nó e da quantidade de nós em cada direção.</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> Boolean <span class="token function">add</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span>
</span><span class="codeline">	<span class="token punctuation">{</span>
</span><span class="codeline">	<span class="token keyword">int</span> comparison <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>comparison <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="codeline">	BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> nextTree <span class="token operator">=</span> comparison <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> leftTree <span class="token operator">:</span> rightTree<span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>nextTree <span class="token operator">==</span> null<span class="token punctuation">)</span>
</span><span class="codeline">	<span class="token punctuation">{</span>
</span><span class="codeline">		nextTree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">		<span class="token keyword">if</span><span class="token punctuation">(</span>comparison <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
</span><span class="codeline">		<span class="token punctuation">{</span>
</span><span class="codeline">			<span class="token function">setRight</span><span class="token punctuation">(</span>nextTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			rightNodes <span class="token operator">++</span><span class="token punctuation">;</span>
</span><span class="codeline">		<span class="token punctuation">}</span>
</span><span class="codeline">		<span class="token keyword">else</span><span class="token punctuation">{</span>
</span><span class="codeline">			<span class="token function">setLeft</span><span class="token punctuation">(</span>nextTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			leftNodes <span class="token operator">++</span><span class="token punctuation">;</span>
</span><span class="codeline">		<span class="token punctuation">}</span>
</span><span class="codeline">		<span class="token function">updateHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token punctuation">}</span>
</span><span class="codeline">	Boolean inserted <span class="token operator">=</span> nextTree<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>
</span><span class="codeline">	<span class="token punctuation">{</span>
</span><span class="codeline">		<span class="token function">incrementNodeCount</span><span class="token punctuation">(</span>comparison <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> nextTree<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">updateHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token punctuation">}</span>
</span><span class="codeline">	<span class="token keyword">return</span> inserted<span class="token punctuation">;</span>
</span><span class="codeline"><span class="token punctuation">}</span></span>
</code></pre>
<p>A condição de parada para com inserção do elemento dispõe-se a partir da linha 6 do código acima. Ela ocorre quando a subárvore de um nó na direção em que a inserção deve ser feita é nula e, após feita a inserção no local correto, junto com o incremento da quantidade de nós na direção em que a inserção foi feita, o método <code>updateHeight()</code> atualiza a altura do nó, caso necessário. As chamadas recursivas , são</p>
<p>A complexidade desse algoritmo também depende da configuração da árvore. Na medida em que o percurso que o algoritmo realiza é o mesmo do algoritmo de busca, vale dizer que a complexidade do método <code>add()</code> é <em>dominada</em> pela complexidade do algoritmo de busca. Localmente, a complexidade da chamada recursiva <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span>
</span></span>
</span></span> mais frequente para uma árvore completa de <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span>
</span></span>
</span></span> nós onde foi possível inserir o elemento desejado pode ser definida por <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mn>17</mn></mrow><annotation encoding="application/x-tex">T(n) = T(\frac{n}{2}) + 17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span>
</span><span class="base"><span class="strut" style="height: 1.095em; vertical-align: -0.345em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span>
</span></span>
</span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span>
</span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span>
</span></span>
</span></span><span class="vlist-s">​</span>
</span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span>
</span></span>
</span></span><span class="mclose nulldelimiter"></span>
</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span>
</span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">17</span>
</span></span>
</span></span> e, pelo teorema mestre, possui complexidade assintótica <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(T(n)) = O(lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span>
</span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal" style="margin-right: 0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span>
</span></span>
</span></span>, considerando as demais operações não-recursivas como em <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span>
</span></span>
</span></span>.</p>
<h3 id="remoção-na-árvore-removevalue-t">1.3. Remoção na árvore: <code>remove(value T)</code></h3>
<hr>
<p>O método para remoção de um elemento da árvore é um pouco mais extenso do que os outros dois. Para ele, foram desenvolvidas duas funções: o método <code>remove(T value)</code>, responsável por encontrar o elemento a ser removido da árvore e atualizar as variáveis relevantes caso a deleção tenha sucesse e; o método <code>removeChildTree(BinaryTree&lt;T&gt; nextTree, Boolean deleteLeft)</code>, responsável por realmente apagar as referências ao elemento deletado e realizar as trocas dos elementos que forem relevantes para a árvore.</p>
<p>o método remove possui complexidade similar à do método <code>search(T value)</code> e da <code>add(T value)</code>, uma vez que segue o mesmo padrão de percurso na árvore e o realiza uma única vez. O código pode ser visto abaixo:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> Boolean <span class="token function">remove</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable<span class="token punctuation">{</span>
</span><span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token keyword">int</span> comparison <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>comparison <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
</span><span class="codeline">		<span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeChildTree</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token punctuation">}</span>
</span><span class="codeline">	BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> nextTree <span class="token operator">=</span> comparison <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>leftTree <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>rightTree<span class="token punctuation">;</span>
</span><span class="codeline">	Boolean success <span class="token operator">=</span> nextTree<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> nextTree<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">updateHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token keyword">return</span> success<span class="token punctuation">;</span>
</span><span class="codeline"><span class="token punctuation">}</span></span>
</code></pre>
<p>Vale dizer que diferentemente das funções anteriormente vistas, o método <code>remove</code> apresenta um indicador de exceção, ocasionado pela presença do método <code>finalize()</code> na chamada do método <code>removeChildTree</code>, na linha 5. Sobre esse método, podemos visualizar seu código logo abaixo:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeChildTree</span><span class="token punctuation">(</span>BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> nextTree<span class="token punctuation">,</span> Boolean deleteLeft<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>
</span><span class="codeline">	<span class="token keyword">switch</span><span class="token punctuation">(</span>nextTree<span class="token punctuation">.</span><span class="token function">getEmptySubTreeAmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</span><span class="codeline">	<span class="token punctuation">{</span>
</span><span class="codeline">		<span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
</span><span class="codeline">			<span class="token keyword">if</span> <span class="token punctuation">(</span>deleteLeft<span class="token punctuation">)</span>	<span class="token function">setLeft</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			<span class="token keyword">else</span>			<span class="token function">setRight</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			nextTree<span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			<span class="token function">updateHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			<span class="token keyword">return</span><span class="token punctuation">;</span>
</span><span class="codeline">		<span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
</span><span class="codeline">			BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> nextNextTree <span class="token operator">=</span> <span class="token punctuation">(</span>nextTree<span class="token punctuation">.</span><span class="token function">leftExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> nextTree<span class="token punctuation">.</span><span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> nextTree<span class="token punctuation">.</span><span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			nextNextTree<span class="token punctuation">.</span><span class="token function">setRoot</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			<span class="token keyword">if</span><span class="token punctuation">(</span>deleteLeft<span class="token punctuation">)</span>	<span class="token function">setLeft</span><span class="token punctuation">(</span>nextNextTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			<span class="token keyword">else</span>			<span class="token function">setRight</span><span class="token punctuation">(</span>nextNextTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			nextTree<span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			<span class="token function">updateHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			<span class="token keyword">return</span><span class="token punctuation">;</span>
</span><span class="codeline">		<span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>
</span><span class="codeline">			BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> eligible <span class="token operator">=</span> <span class="token function">findEligible</span><span class="token punctuation">(</span>nextTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			<span class="token function">swapTree</span><span class="token punctuation">(</span>eligible<span class="token punctuation">,</span> nextTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			nextTree<span class="token punctuation">.</span><span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeChildTree</span><span class="token punctuation">(</span>nextTree<span class="token punctuation">,</span> nextTree<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>nextTree<span class="token punctuation">.</span><span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">			<span class="token keyword">return</span><span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token punctuation">}</span>
</span><span class="codeline"><span class="token punctuation">}</span></span>
</code></pre>
<p>Como dito, o método realiza a deleção de um nó da árvore dado seu endereço. Vale ressaltar que o nó deletado precisa ser uma subárvore do objeto que chama o método. A exclusão é feita em <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span>
</span></span>
</span></span> no melhor caso, ao passo que não é necessário percorrer a árvore inteira nenhuma vez adicional. Para realizar a deleção corretamente, o processo possui 3 casos, baseados na quantidade de nós filhos da árvore. Os dois primeiros casos realizam a deleção de forma simples, com a complexidade descrita acima.</p>
<p>Para o terceiro caso, onde o nó-alvo não possui nenhuma subárvore vazia, existe um método auxiliar <code>findEligible(BinaryTree&lt;T&gt; victim)</code>, responsável por obter o nó da árvore que assumirá o lugar do nó deletado. Esse nó garantidamente possui um ou nenhum nó filho. Para remover o nó desejado, basta trocá-lo com o elemento obtido pela <code>findEligible</code> e, em seguida, remover o nó-alvo na sua nova posição através de uma chamada recursiva do método <code>removeChildTree</code>, que inevitavelmente termina em um dos casos anteriores.</p>
<p>O código para a busca pelo sucessor é simples e pode ser visto logo abaixo:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">private</span> BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">findEligible</span><span class="token punctuation">(</span>BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> victim<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="codeline">	BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> eligible <span class="token operator">=</span> null<span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>victim<span class="token punctuation">.</span><span class="token function">leftExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</span><span class="codeline">	<span class="token punctuation">{</span>
</span><span class="codeline">		eligible <span class="token operator">=</span> victim<span class="token punctuation">.</span><span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">		<span class="token keyword">while</span><span class="token punctuation">(</span>eligible<span class="token punctuation">.</span><span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>
</span><span class="codeline">		<span class="token punctuation">{</span>
</span><span class="codeline">			eligible <span class="token operator">=</span> eligible<span class="token punctuation">.</span><span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">		<span class="token punctuation">}</span>
</span><span class="codeline">		<span class="token keyword">return</span> eligible<span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token punctuation">}</span>
</span><span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>victim<span class="token punctuation">.</span><span class="token function">rightExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</span><span class="codeline">	<span class="token punctuation">{</span>
</span><span class="codeline">		eligible <span class="token operator">=</span> victim<span class="token punctuation">.</span><span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">		<span class="token keyword">while</span><span class="token punctuation">(</span>eligible<span class="token punctuation">.</span><span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>
</span><span class="codeline">		<span class="token punctuation">{</span>
</span><span class="codeline">			eligible <span class="token operator">=</span> eligible<span class="token punctuation">.</span><span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="codeline">		<span class="token punctuation">}</span>
</span><span class="codeline">		<span class="token keyword">return</span> eligible<span class="token punctuation">;</span>
</span><span class="codeline">	<span class="token punctuation">}</span>
</span><span class="codeline">	<span class="token keyword">return</span> null<span class="token punctuation">;</span>
</span><span class="codeline"><span class="token punctuation">}</span></span>
</code></pre>
<p>Isto posto, por ser um algoritmo que itera sobre os filhos do nó-alvo até obter o seu sucessor, um por vez, a complexidade <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span>
</span></span>
</span></span> do algoritmo no seu pior caso pode ser definida por <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>4</mn><mo>⋅</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">T(n) = 4\cdot(n-3) + 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span>
</span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.222222em;"></span>
</span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span>
</span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span>
</span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span>
</span></span>
</span></span>. Logo, pelo método da substituição temos <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(T(n)) = O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span>
</span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span>
</span></span>
</span></span>.</p>
<h2 id="algoritmos-requisitados">2. Algoritmos requisitados</h2>
<p>Nessa secção, apresentaremos os algoritmos cuja implementação não foi explicitamente requisitada na especificação do projeto.</p>
<h3 id="encontrar-o-n-ésimo-elemento-findelementbyindex">2.1. Encontrar o n-ésimo elemento: <em>findElementByIndex</em></h3>
<hr>
<p>O algoritmo para encontrar o enésimo elemento que implementamos utiliza duas funções. o método wrapper <strong>findElementByIndex(int n)</strong> é a pública e serve para inicializar uma referência ao índice pretendido, enquanto o método privada <strong>findElementByIndexRecursive(int n)</strong> realiza a maior parte do trabalho. Como visto no código abaixo:</p>
<p>Linhas 266 -&gt; 285</p>
<p>Em suma, o algoritmo inicializa uma referência ao índice n e em seguida, inicializa uma variável do tipo T</p>

    </div>
  </div>
</body>

</html>
