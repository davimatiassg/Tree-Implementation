<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trabalho de EDB2</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#implementação-da-árvore">Implementação da Árvore</a></li>
<li><a href="#análise-dos-algoritmos">Análise dos Algoritmos</a>
<ul>
<li><a href="#algoritmos-da-implementação-básica"><bold>1. Algoritmos da Implementação Básica</bold></a></li>
<ul>
	<li><a href="#busca-na-árvore-searcht-value">1.1. Busca na árvore: <code>search(T value)</code></a></li>
	<li><a href="#inserção-na-árvore-addvalue-t">1.2. Inserção na árvore: <code>add(value T)</code></a></li>
	<li><a href="#remoção-na-árvore-removevalue-t">1.3. Remoção na árvore: <code>remove(value T)</code></a></li>
</ul>
<li><a href="#algoritmos-requisitados"><bold>2. Algoritmos requisitados</bold></a></li>
<ul>
	<li><a href="#encontrar-o-n-ésimo-elemento-findelementbyindexint-n">2.1. Encontrar o n-ésimo elemento: <code>findElementByIndex(int n)</code></a></li>
<li><a href="#encontrar-o-índice-n-de-certo-elemento-findindexbyelementt-value">2.2. Encontrar o índice n de certo elemento: <code>findIndexByElement(T value)</code></a></li>
<li><a href="#obter-a-mediana-da-árvore-calculatemedian">2.3. Obter a mediana da Árvore: <code>calculateMedian()</code></a></li>
<li><a href="#obter-a-média-da-árvore-calculateaveraget-root">2.4. Obter a média da Árvore: <code>calculateAverage(T root)</code></a></li>
<li><a href="#verificar-se-a-árvore-é-cheia-isfull">2.5 Verificar se a árvore é cheia: <code>isFull()</code></a></li>
<li><a href="#verificar-se-a-árvore-é-completa-iscomplete">2.6 Verificar se a árvore é completa: <code>isComplete()</code></a></li>
<li><a href="#impressão-em-préordem-tostringpreorder">2.7 Impressão em préordem: <code>toStringPreOrder()</code></a></li>
<li><a href="#impressão-em-formatos-diferentes-tostringint-i">2.8 Impressão em formatos diferentes: <code>toString(int i)</code></a></li>
</ul>
</ul>
</li>
<li><a href="#conclusao">Conclusão</a>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">

<h1 id="Start">Trabalho de Estruturas de Dados Básicas 2</h1>
<h4>Professor Dr. Sidemar Fideles Cezario</h4>

<h4>Alunos:</h4>

<ul>
	<li><a href="https://github.com/cinquilcinquil">Carlos Eduardo Valle Rosa Filho </a> </li>
	<li><a href="https://github.com/davimatiassg">Davi Matias Soares Genuino </a></li>
</ul>
 
      
<h1 id="implementação-da-árvore">Implementação da Árvore</h1>
<p>A árvore binária de busca foi implementada utilizando apenas uma classe (BinaryTree). A classe possui um argumento de tipo genérico T, onde T é uma classe que herda da classe Comparable. Isso é importante por que é através dessa classe que poderemos realizar comparações entre os elementos da árvore (através do método <code>T1.compareTo(T2)</code>, que retorna -1 caso <code>T1 &lt; T2</code>, 0 caso <code>T1 = T2</code> e 1 caso <code>T1 &gt; T2</code>). Para a execução do código apresentado neste trabalho, usaremos a classe <em>Integer</em> no lugar do argumento T.</p>
<p>Cada nó da árvore, representado por um objeto da classe <em>BinaryTree</em> possui 7 atributos, todos de aceso restrito ao pacote <em>tree</em> (que apenas contém a classe BinaryTree, até o momento de escrita deste documento). Estes são:</p>
<p>T <strong>value</strong>: O valor armazenado nó da árvore.</p>
<p>int <strong>height</strong>: Um inteiro positivo que representa a altura do nó, em comparação com o seu “galho” mais distante.</p>
<p>int <strong>leftNodes</strong> e <strong>rightNodes</strong>: Inteiros positivos que respectivamente representam o número de nós nas subárvores esquerda e direita deste nó.</p>
<p>BinaryTree <strong>root</strong>: O nó raiz (ou a árvore pai) desta instância da BinaryTree. Caso não seja especificado um valor para a raiz de uma BinaryTree, essa referência é assinalada para a própria instância (ou seja, a instância é a própria raiz).</p>
<p>BinaryTree <strong>leftTree</strong> e <strong>rightTree</strong>: Referências para as árvores esquerda e direita desta instância da BinaryTree. Essas referências permanecem com os valores <em>null</em> caso não hajam subárvores para esse nó.</p>
<p>Atestamos que a implementação da árvore binária não é responsável por lidar com erros de uso, tais como tentativas de busca com argumentos nulos ou inválidos.</p>
<h1 id="análise-dos-algoritmos">Análise dos Algoritmos</h1>
<p>Agora, descreveremos o processe de execução de cada um dos algoritmos implementados na classe <em>BinaryTree</em>. Para tal, considere uma árvore binária com <em>n</em> nós.</p>
<h2 id="algoritmos-da-implementação-básica">1. Algoritmos da Implementação Básica</h2>
<p>Apresentaremos aqui alguns dos algoritmos básicos que devem estar presentes na estrutura de uma árvore, mesmo que não estivessem sendo explicitamente requisitados na especificação.</p>
<h3 id="busca-na-árvore-searcht-value">1.1. Busca na árvore: <code>search(T value)</code></h3>
<hr>
<p>O algoritmo de busca de uma árvore binária é provavelmente uma das partes mais vantajosas desse tipo de implementação. O método <code>search(T value)</code>, chamado através da referência de um objeto <em>BinaryTree</em>, é responsável por realizar a busca por determinado valor no próprio objeto chamador do método e, caso necessário, na subárvore que pode contê-lo. O algoritmo procede de maneira recursiva, como visto a seguir:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">search</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">int</span> comparison <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> nextTree <span class="token operator">=</span> comparison <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> leftTree <span class="token operator">:</span> rightTree<span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>comparison <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>nextTree <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> nextTree<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>A execução do algoritmo segue um fluxo simples. Compara-se o valor pesquisado com o valor do nó atual para decidir a direção em que a recursão do algoritmo deve acontecer e, em seguida, verifica-se se alguma das condições de parada foi atingida, dando sequência à recursão no caso contrário.</p>
<p>Para a análise da complexidade assintótica, consideremos uma árvore binária de tamanho n. Note que a complexidade desse algoritmo depende da configuração da árvore. O pior caso dessa recursão se dá quando a busca acontece numa árvore cujos nós possuem exatamente um nó filho. Para tal configuração, o algorítmo é <em>O(n)</em>, uma vez que todos os nós precisam ser comparados. No caso preferível da árvore ser completa, a complexidade T(n) de cada chamada recursiva pode ser obtida por <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">T(n) = T(\frac{n}{2}) + 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.095em; vertical-align: -0.345em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span></span></span></span></span>. Pelo segundo caso do teorema mestre, portanto, temos <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(T(n)) = O(lg(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span>.</p>
<h3 id="inserção-na-árvore-addvalue-t">1.2. Inserção na árvore: <code>add(value T)</code></h3>
<hr>
<p>Abrindo mão do uso do método <code>search</code> para buscar pelo nó externo onde o elemento desejado pode ser inserido na árvore, o método <code>add(T value)</code> possui algumas peculiaridades mais complexas. Como visível abaixo, o algoritmo também segue um processe recursivo, que percorre a árvore apenas uma vez e, com base no retorno do método (um booleano que indica se foi possível inserir o elemento desejado), realiza a atualização da altura do nó e da quantidade de nós em cada direção.</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> Boolean <span class="token function">add</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">int</span> comparison <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>comparison <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="codeline">	BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> nextTree <span class="token operator">=</span> comparison <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> leftTree <span class="token operator">:</span> rightTree<span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>nextTree <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">		nextTree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">if</span><span class="token punctuation">(</span>comparison <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">			<span class="token function">setRight</span><span class="token punctuation">(</span>nextTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			rightNodes <span class="token operator">++</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token punctuation">}</span>
<span class="codeline">		<span class="token keyword">else</span><span class="token punctuation">{</span>
<span class="codeline">			<span class="token function">setLeft</span><span class="token punctuation">(</span>nextTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			leftNodes <span class="token operator">++</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token punctuation">}</span>
<span class="codeline">		<span class="token function">updateHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token punctuation">}</span>
<span class="codeline">	Boolean inserted <span class="token operator">=</span> nextTree<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">		<span class="token function">incrementNodeCount</span><span class="token punctuation">(</span>comparison <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> nextTree<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">updateHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token punctuation">}</span>
<span class="codeline">	<span class="token keyword">return</span> inserted<span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>A condição de parada para com inserção do elemento dispõe-se a partir da linha 6 do código acima. Ela ocorre quando a subárvore de um nó na direção em que a inserção deve ser feita é nula e, após feita a inserção no local correto, junto com o incremento da quantidade de nós na direção em que a inserção foi feita, o método <code>updateHeight()</code> atualiza a altura do nó, caso necessário.</p>
<p>A complexidade desse algoritmo também depende da configuração da árvore. Na medida em que o percurso que o algoritmo realiza é o mesmo do algoritmo de busca, vale dizer que a complexidade assintótica do método <code>add()</code> é idêntica a do algoritmo de busca, uma vez que eles realizam o mesmo número de acessos aos nós da árvore. Localmente, a complexidade da chamada recursiva <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> mais frequente para uma árvore completa de <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> nós onde foi possível inserir o elemento desejado pode ser definida por <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mn>17</mn></mrow><annotation encoding="application/x-tex">T(n) = T(\frac{n}{2}) + 17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.095em; vertical-align: -0.345em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">17</span></span></span></span></span> e, pelo teorema mestre, possui complexidade assintótica <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(T(n)) = O(lg n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal" style="margin-right: 0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>, considerando as demais operações não-recursivas como em <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>.</p>
<h3 id="remoção-na-árvore-removevalue-t">1.3. Remoção na árvore: <code>remove(value T)</code></h3>
<hr>
<p>O método para remoção de um elemento da árvore é um pouco mais extenso do que os outros dois. Para ele, foram desenvolvidas duas funções: o método <code>remove(T value)</code>, responsável por encontrar o elemento a ser removido da árvore e atualizar as variáveis relevantes caso a deleção tenha sucesse e; o método <code>removeChildTree(BinaryTree&lt;T&gt; nextTree, Boolean deleteLeft)</code>, responsável por realmente apagar as referências ao elemento deletado e realizar as trocas dos elementos que forem relevantes para a árvore.</p>
<p>o método remove possui complexidade similar à do método <code>search(T value)</code> e da <code>add(T value)</code>, uma vez que segue o mesmo padrão de percurso na árvore e o realiza uma única vez. O código pode ser visto abaixo:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> Boolean <span class="token function">remove</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable<span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">int</span> comparison <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>comparison <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">		<span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeChildTree</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token punctuation">}</span>
<span class="codeline">	BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> nextTree <span class="token operator">=</span> comparison <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>leftTree <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>rightTree<span class="token punctuation">;</span>
<span class="codeline">	Boolean success <span class="token operator">=</span> nextTree<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> nextTree<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">updateHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> success<span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>Vale dizer que diferentemente das funções anteriormente vistas, o método <code>remove</code> apresenta um indicador de exceção, ocasionado pela presença do método <code>finalize()</code> na chamada do método <code>removeChildTree</code>, na linha 5. Sobre esse método, podemos visualizar seu código logo abaixo:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeChildTree</span><span class="token punctuation">(</span>BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> nextTree<span class="token punctuation">,</span> Boolean deleteLeft<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">switch</span><span class="token punctuation">(</span>nextTree<span class="token punctuation">.</span><span class="token function">getEmptySubTreeAmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">		<span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
<span class="codeline">			<span class="token keyword">if</span> <span class="token punctuation">(</span>deleteLeft<span class="token punctuation">)</span>	<span class="token function">setLeft</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			<span class="token keyword">else</span>			<span class="token function">setRight</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			nextTree<span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			<span class="token function">updateHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
<span class="codeline">			BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> nextNextTree <span class="token operator">=</span> <span class="token punctuation">(</span>nextTree<span class="token punctuation">.</span><span class="token function">leftExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> nextTree<span class="token punctuation">.</span><span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> nextTree<span class="token punctuation">.</span><span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			nextNextTree<span class="token punctuation">.</span><span class="token function">setRoot</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			<span class="token keyword">if</span><span class="token punctuation">(</span>deleteLeft<span class="token punctuation">)</span>	<span class="token function">setLeft</span><span class="token punctuation">(</span>nextNextTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			<span class="token keyword">else</span>			<span class="token function">setRight</span><span class="token punctuation">(</span>nextNextTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			nextTree<span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			<span class="token function">updateHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>
<span class="codeline">			BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> eligible <span class="token operator">=</span> <span class="token function">findEligible</span><span class="token punctuation">(</span>nextTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			<span class="token function">swapTree</span><span class="token punctuation">(</span>nextTree<span class="token punctuation">,</span> eligible<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			nextTree<span class="token punctuation">.</span><span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeChildTree</span><span class="token punctuation">(</span>eligible<span class="token punctuation">,</span> eligible<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>eligible<span class="token punctuation">.</span><span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">			<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token punctuation">}</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>Como dito, o método realiza a deleção de um nó da árvore dado seu endereço. Vale ressaltar que o nó deletado precisa ser uma subárvore do objeto que chama o método. A exclusão é feita em <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> no melhor caso, ao passo que não é necessário percorrer a árvore inteira nenhuma vez adicional. Para realizar a deleção corretamente, o processo possui 3 casos, baseados na quantidade de nós filhos da árvore. Os dois primeiros casos realizam a deleção de forma simples, com a complexidade descrita acima.</p>
<p>Para o terceiro caso, onde o nó-alvo não possui nenhuma subárvore vazia, existe um método auxiliar <code>findEligible(BinaryTree&lt;T&gt; victim)</code>, responsável por obter o nó da árvore que assumirá o lugar do nó deletado. Esse nó garantidamente possui um ou nenhum nó filho. Para remover o nó desejado, basta trocá-lo com o elemento obtido pela <code>findEligible</code> e, em seguida, remover o nó-alvo na sua nova posição através de uma chamada recursiva do método <code>removeChildTree</code>, que inevitavelmente termina em um dos casos anteriores.</p>
<p>O código para a busca pelo sucessor é simples e pode ser visto logo abaixo:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">private</span> BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">findEligible</span><span class="token punctuation">(</span>BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> victim<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="codeline">	BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> eligible <span class="token operator">=</span> null<span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>victim<span class="token punctuation">.</span><span class="token function">leftExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">		eligible <span class="token operator">=</span> victim<span class="token punctuation">.</span><span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">while</span><span class="token punctuation">(</span>eligible<span class="token punctuation">.</span><span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">			eligible <span class="token operator">=</span> eligible<span class="token punctuation">.</span><span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token punctuation">}</span>
<span class="codeline">		<span class="token keyword">return</span> eligible<span class="token punctuation">;</span>
<span class="codeline">	<span class="token punctuation">}</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>victim<span class="token punctuation">.</span><span class="token function">rightExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">		eligible <span class="token operator">=</span> victim<span class="token punctuation">.</span><span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">while</span><span class="token punctuation">(</span>eligible<span class="token punctuation">.</span><span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">			eligible <span class="token operator">=</span> eligible<span class="token punctuation">.</span><span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token punctuation">}</span>
<span class="codeline">		<span class="token keyword">return</span> eligible<span class="token punctuation">;</span>
<span class="codeline">	<span class="token punctuation">}</span>
<span class="codeline">	<span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>Isto posto, por ser um algoritmo que itera sobre os filhos do nó-alvo até obter o seu sucessor, um por vez, a complexidade <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> do algoritmo no seu pior caso pode ser definida por <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>4</mn><mo>⋅</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">T(n) = 4\cdot(n-3) + 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span></span></span></span></span>. Logo, pelo método da substituição temos <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(T(n)) = O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
<h2 id="algoritmos-requisitados">2. Algoritmos requisitados</h2>
<p>Nessa secção, apresentaremos os algoritmos cuja implementação foi explicitamente requisitada na especificação do projeto.</p>
<h3 id="encontrar-o-n-ésimo-elemento-findelementbyindexint-n">2.1. Encontrar o n-ésimo elemento: <code>findElementByIndex(int n)</code></h3>
<hr>
<p>O algoritmo para encontrar o n-ésimo elemento que implementamos utiliza duas funções. O método wrapper <code>findElementByIndex(int n)</code> é a chamada pública e serve para inicializar uma referência ao índice pretendido, enquanto o método privado <strong>findElementByIndexRecursive(int n)</strong> realiza a maior parte do trabalho. Como visto no código abaixo:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> T <span class="token function">findElementByIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">int</span> n_<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> <span class="token function">findElementByIndexRecursive</span><span class="token punctuation">(</span>n_<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">private</span> T <span class="token function">findElementByIndexRecursive</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">	T v <span class="token operator">=</span> null<span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">leftExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> v <span class="token operator">=</span> <span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findElementByIndexRecursive</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="codeline">	n<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">--</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rightExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> v <span class="token operator">=</span> <span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findElementByIndexRecursive</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>O fluxo de execução do algorimto é bastante direto: percorrendo a árvore em ordem simétrica, o algoritmo checa de a referência ao objeto inicializado no método <em>wrapper</em> contém o valor 0. Caso contrário, o algoritmo continua a percorrer a árvore.</p>
<p>Note que, para todos os casos, a complexidade desse algoritmo é dominada pela complexidade do percurso em órdem simétrica, uma vez que todos os nós da árvore precisam ser percorridos até que o <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mover accent="true"><mi>e</mi><mo>ˊ</mo></mover><mi>s</mi><mi>i</mi><mi>m</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">n</annotation>-ésimo</semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.69444em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal">e</span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.19444em;"><span class="mord">ˊ</span></span></span></span></span></span></span><span class="mord mathnormal">s</span><span class="mord mathnormal">im</span><span class="mord mathnormal">o</span></span></span></span></span> elemento seja encontrado. Logo, a complexidade do algoritmo é <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(n, x)) = O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>, onde <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> é o índice buscado e <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> é número de elementos na árvore.</p>
<h3 id="encontrar-o-índice-n-de-certo-elemento-findindexbyelementt-value">2.2. Encontrar o índice n de certo elemento: <code>findIndexByElement(T value)</code></h3>
<p>A similaridade do nome deste método com o método anterior não é vã. De fato, ambos os algoritmos operam de maneira muito similar, percorrendo recursivamente a árvore em ordem simétrica e atualizando uma referência que indica o índice do valor, fato que pode ser constatado logo a seguir:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findIndexByElement</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">int</span> n_<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> <span class="token function">findIndexByElementRecursive</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> n_<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findIndexByElementRecursive</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">leftExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> i <span class="token operator">=</span> <span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findIndexByElementRecursive</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="codeline">	n<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">		<span class="token keyword">int</span> tmp <span class="token operator">=</span> n<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="codeline">		n<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
<span class="codeline">	<span class="token punctuation">}</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rightExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> i <span class="token operator">=</span> <span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findIndexByElementRecursive</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>Como esperado, a complexidade assintótica desse método também é dominada pelo percurso em órdem simétrica. Assim, temos que o algoritmo também é <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>, pelos mesmos motivos que o algoritmo do item 2.1.</p>
<h3 id="obter-a-mediana-da-árvore-calculatemedian">2.3. Obter a mediana da Árvore: <code>calculateMedian()</code></h3>
<hr>
<p>O método para calcular a mediana é bastante simples, ainda mais que os anteriores. Dado que os nós possuem o número de subárvores em cada direção (esquerda e direita) armazenados em si, bastou que obtivéssemos calculássemos o índice da mediana (que é a metade do número de nós da árvore) e utilizássemos o supracitado método <code>findElementByIndex</code> para encontrar o elemento na posição esperada. Segue abaixo o código implementado:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> T <span class="token function">calculateMedian</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">getChildAmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	v <span class="token operator">=</span>  <span class="token punctuation">(</span>v <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">=</span> v<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">:</span> v <span class="token operator">=</span> v<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> <span class="token function">findElementByIndex</span><span class="token punctuation">(</span>v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>Perceba que o método <code>getChildAmount()</code> nada mais faz do que retornar a soma do número de nós à direita e à esquerda do nó atual. Assim, a complexidade desse algoritmo é inteiramente dominada pela complexidade do método <code>findElementByIndex</code>, ou seja, é <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> tal como ele.</p>
<h3 id="obter-a-média-da-árvore-calculateaveraget-root">2.4. Obter a média da Árvore: <code>calculateAverage(T root)</code></h3>
<hr>
<p>O algoritmo para calcular a média da árvore segundo a assinatura requisitada na especificação do projeto é dividido em 3 métodos. Para fins de elucidação da funcionalidade da tríade, mais vale que apresentemos os códigos antes de qualquer explicação mais rebuscada. Assim sendo, observemo-los:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">calculateAverage</span><span class="token punctuation">(</span>T root<span class="token punctuation">)</span> <span class="token keyword">throws</span> InvalidTargetObjectTypeException <span class="token punctuation">{</span>
<span class="codeline">	BinaryTree rt <span class="token operator">=</span> <span class="token function">search</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span>rt <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> rt<span class="token punctuation">.</span><span class="token function">calculateAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>Este primeiro código contém a assinatura pretendida para a função. Recebendo como argumento apenas o valor de um suposto elemento da árvore, esse algoritmo busca a subárvore que contém esse valor na sua raiz e, em seguida, chama o método <code>calculateAverage()</code> através do objeto da subárvore. Esse método será responsável por calcular a média da subárvore. Vale destacar que a declaração do lançamento da exceção refere-se à possibilidade da árvore armazenar elementos não númericos, como strings e outras árvores. Nesse caso, o método sempre retorna a exceção descrita.</p>
<p>A complexidade do método acima, no seu pior caso (similar aos piores casos já descritos - onde cada nó da árvore possui um ou menos nós filhos) pode ser descrita da seguinte forma: seja <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> o número de nós na árvore e seja <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">m</span></span></span></span></span> o número de subnós da árvore que contém o valor passado como argumento da função. Disso, a complexidade <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> desse algoritmo é descrita pela equação <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>U</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>+</mo><mi>V</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = U(n-m) + 2 + V(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">U</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>, onde <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">U</span></span></span></span></span> descreve a complexidade do método <code>search(T value)</code> no seu pior caso (ver item 1.1.), e <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.22222em;">V</span></span></span></span></span> descreve a complexidade do método calculateAverage, disposto logo abaixo:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">calculateAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InvalidTargetObjectTypeException<span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">		String s <span class="token operator">=</span> <span class="token string">"Can not calculate the average of non-numeric values and Class '"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"' cannot be asserted to a numerical type."</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidTargetObjectTypeException</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token punctuation">}</span>
<span class="codeline">	Double averageParcels<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Number<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sumSubtrees</span><span class="token punctuation">(</span>averageParcels<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> averageParcels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token function">getChildAmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>O método <code>calculateAverage()</code> não recebe argumentos e calcula a média do objeto <code>BinaryTree</code> que o chamou. O método pode ser caracterizado como um <em>wrapper</em> para o terceiro e último método deste quesito, uma vez que sua função é inicializar uma referência à um objeto que armazenará o somatório de todos os nós a partir do chamador e, após a realização das somas, dividir o total pela quantidade de nós que foram somados. O somatório é realizado recursivamente pelo método <code>sumSubtrees</code>, que recebe uma referência para o objeto que armazena o valor do somatório. Esse método pode ser visto abaixo.</p>
<p>A complexidade desse método é definida pelo número de chamadas que a recursão <code>sumSubtrees</code> realizar. Assim sendo, descrevemos a complexidade <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> desse método como <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mi>W</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">V(m) = W(m) + 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">8</span></span></span></span></span>, onde <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span></span></span></span></span> é a complexidade do método <code>sumSubtrees</code>, exposto a seguir:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sumSubtrees</span><span class="token punctuation">(</span>Double averageParcels<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">leftExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">		averageParcels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Number<span class="token punctuation">)</span><span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sumSubtrees</span><span class="token punctuation">(</span>averageParcels<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token punctuation">}</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rightExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">		averageParcels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Number<span class="token punctuation">)</span> <span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sumSubtrees</span><span class="token punctuation">(</span>averageParcels<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token punctuation">}</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>A visibilidade privada desse método objetiva garantir que ele não será utilizado fora do método <code>calculateAverage()</code>, onde não há a verificação de que os objetos armazenados na árvore sequer são “somáveis”. Com isso em mente, o método percorre a árvore recursivamente em pré-ordem e adiciona os valores dos nós à referência <code>averageParcels[]</code>.</p>
<p>Note que, uma vez que percorre todos os <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">m</span></span></span></span></span> nós da árvore uma única vez, esse algoritmo tem complexidade linear, ou seja, <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(W(m)) = O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">))</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>. Para analisar a complexidade total da chamada do primeiro método apresentado nesse item (que também é a execução mais dispendiosa dentre os três), tomemos as três equações que apresentamos e poderemos perceber que a complexidade do primeiro método deste quesito, o <code>calculateAverage(T root)</code>, também é linear:</p>
<p>Como <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(W(m)) = O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">))</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>, seja <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><msub><mi mathvariant="double-struck">R</mi><mrow><mo>&gt;</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">c \in \mathbb{R}_{&gt;0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.86626em; vertical-align: -0.17737em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">&gt;</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.17737em;"><span class=""></span></span></span></span></span></span></span></span></span></span> tal que, eventualmente, <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>c</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">W(m) \leq cm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">m</span></span></span></span></span>. Logo, note que:<br>
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mtable rowspacing="0.2500em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>c</mi><mi>m</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow>  <mo>⟹</mo>  <mi>W</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mn>8</mn><mo>≤</mo><mi>c</mi><mi>m</mi><mo>+</mo><mn>8</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow>  <mo>⟹</mo>  <mi>W</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mn>8</mn><mo>≤</mo><mn>8</mn><msub><mi>c</mi><mn>1</mn></msub><mi>m</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow>  <mo>⟹</mo>  <mi>V</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>≤</mo><mn>8</mn><mi>c</mi><mi>m</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow>  <mo>⟹</mo>  <mi>V</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mtd><mtd width="50%"></mtd><mtd><mrow><mtext>(</mtext><mrow><mtext>Para&nbsp;todo&nbsp;</mtext><mstyle scriptlevel="0" displaystyle="false"><mi>m</mi><mo>≥</mo><mn>1</mn></mstyle></mrow><mtext>)</mtext></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
W(m) \leq cm &amp;\implies W(m) + 8 \leq cm + 8\\
&amp;\implies W(m) + 8 \leq 8c_1m \tag{Para todo $m \geq1 $}\\
&amp;\implies V(m) \leq 8cm\\
&amp;\implies V(m) = O(m)\\
\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 6em; vertical-align: -2.75em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 3.25em;"><span class="" style="top: -5.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">m</span></span></span><span class="" style="top: -3.91em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"></span></span><span class="" style="top: -0.91em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.75em;"><span class=""></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 3.25em;"><span class="" style="top: -5.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">8</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">8</span></span></span><span class="" style="top: -3.91em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">8</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">8</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal">m</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal" style="margin-right: 0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">8</span><span class="mord mathnormal">c</span><span class="mord mathnormal">m</span></span></span><span class="" style="top: -0.91em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal" style="margin-right: 0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.75em;"><span class=""></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height: 6em; vertical-align: -2.75em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">Para&nbsp;todo&nbsp;</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></span><br>
Analogamente, como <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(m) = O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>, temos <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(m) +2 = O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>. Disso, como pelo item 1.1. temos que <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">U</span></span></span></span></span> é linear, note que:<br>
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.2500em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>U</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>+</mo><mi>V</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow>  <mo>⟹</mo>  <mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow>  <mo>⟹</mo>  <mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow>  <mo>⟹</mo>  <mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
T(n) = U(n-m) + 2 + V(m) &amp;\implies T(n) = O(n-m) + O(m)\\
&amp;\implies T(n) = O(n -m + m)\\
&amp;\implies T(n) = O(n)\\
\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 4.5em; vertical-align: -2em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.5em;"><span class="" style="top: -4.66em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">U</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathnormal" style="margin-right: 0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span><span class="" style="top: -3.16em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"></span></span><span class="" style="top: -1.66em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2em;"><span class=""></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.5em;"><span class="" style="top: -4.66em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span><span class="" style="top: -3.16em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span><span class="" style="top: -1.66em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span><br>
Assim, obtemos que a complexidade <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> do método <code>calculateAverage(T root)</code>, realmente é linear.</p>
<h3 id="verificar-se-a-árvore-é-cheia-isfull">2.5 Verificar se a árvore é cheia: <code>isFull()</code></h3>
<hr>
<p>Para verificar se a árvore é cheia, isto é, se todas as suas folhas estão no último nível, implementamos um código de funcionamento similar aos que já apresentamos acima: o método <code>isFull()</code> inicializa uma referência a um objeto - desta vez um booleano - que será alterada conforme a progressão de um algoritmo recursivo. A implementação do <code>isFull()</code> é mostrada abaixo:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//Metal Alchemist</span>
<span class="codeline">	<span class="token keyword">boolean</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token function">completenessCheck</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>Como esperado, o algoritmo recursivo em questão é o método <code>completenessCheck</code>. O processo de execução desse método é bastante interessante, principalmente considerando que ele será utilizado tanto neste quesito quanto no próximo. O código da implementação pode ser visto em seguida:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">completenessCheck</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> subTreeAmountGap<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">leftExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> t <span class="token operator">+=</span> <span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">rightExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> t <span class="token operator">-=</span> <span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&gt;</span> heighGap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="codeline">		b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token punctuation">}</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">leftExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">completenessCheck</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> heighGap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">rightExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">completenessCheck</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> heighGap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>O processo descrito pelo algoritmo consiste em verificar a quantidade de subárvores em cada um dos nós, recursivamente. A ideia central do algoritmo é, para cada nó da árvore verificar que a diferença entre as alturas dos nós filhos é 0. Em caso afirmativo, como é de se esperar o algoritmo deverá percorrer a árvore inteira até constatar esse fato, no último nível (pior caso). No caso contrário, o algoritmo interrompe a recurssão ao atribuir o valor <code>false</code> à referência passada, ativando a condição de parada na primeira linha do código.</p>
<p>Visto que no seu pior caso o algoritmo percorre a árvore inteira uma única vez, a sua complexidade, definida na equação <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mn>13</mn></mrow><annotation encoding="application/x-tex">T(n) = 2T(\frac{n}{2}) + 13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.095em; vertical-align: -0.345em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">13</span></span></span></span></span> é trivialmente linear (pelo 1º caso do teorema mestre).</p>
<h3 id="verificar-se-a-árvore-é-completa-iscomplete">2.6 Verificar se a árvore é completa: <code>isComplete()</code></h3>
<hr>
<p>O código para obter se uma árvore é completa é extremamente similar ao empregado na verificação se a árvore é cheia, a saber:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">boolean</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token function">completenessCheck</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>A única alteração nesse código em relação ao anterior, além do nome, é que a chamada do método <code>completenessCheck</code> na linha 2 passa o valor 1 (e não 0, como no quesito anterior) para o argumento <code>heightGap</code> do método, indicando que pode haver uma diferença de altura de uma unidade entre os nós filhos de determinado nó da árvore, como é comum observarmos em árvores completas não-cheias.</p>
<p>A complexidade deste algoritmo é idêntica à do quesito anterior.</p>
<h3 id="impressão-em-préordem-tostringpreorder">2.7 Impressão em préordem: <code>toStringPreOrder()</code></h3>
<hr>
<p>Para realizar a impressão em pré-ordem da árvore, utilizamos o algoritmo padrão para esse tipo de acesso, como visto abaixo:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> String <span class="token function">toStringPreOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">		String s <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="codeline">		s <span class="token operator">+=</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">leftExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> s <span class="token operator">+=</span> <span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toStringPreOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rightExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> s <span class="token operator">+=</span> <span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toStringPreOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		<span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>O algoritmo segue uma estrutura simples, que concatena a um objeto string os valores dos nós percorridos em pré-ordem para então retorna-lo. A complexidade desse algoritmo é linear, visto que é dominada pela complexidade do percurso.</p>
<h3 id="impressão-em-formatos-diferentes-tostringint-i">2.8 Impressão em formatos diferentes: <code>toString(int i)</code></h3>
<hr>
<p>Para a realização da impressão, utilizamos o método <code>toString(int i)</code> responsável unicamente por chamar o método correspondente ao tipo de impressão requisitado. A saber:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">	String s <span class="token operator">=</span> <span class="token string">"BinaryTree\n"</span> <span class="token operator">+</span> <span class="token string">"Root: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">showTreeDashes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">showTreeChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>A impressão em hierarquia é feita pelo método <code>showTreeDashes()</code>, apresentado sob a seguinte forma:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> String <span class="token function">showTreeDashes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">return</span> <span class="token function">showTreeDashes</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span>
<span class="codeline">	<span class="token string">"_____________________________________________________"</span><span class="token operator">+</span>
<span class="codeline">	<span class="token string">"_____________________________________________________"</span><span class="token operator">+</span>
<span class="codeline">	<span class="token string">"_____________________________________________________"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">private</span> String <span class="token function">showTreeDashes</span><span class="token punctuation">(</span>String spaces<span class="token punctuation">,</span> String dashes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="codeline">	<span class="token keyword">try</span><span class="token punctuation">{</span>
<span class="codeline">		DecimalFormat df <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecimalFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		df<span class="token punctuation">.</span><span class="token function">setMaximumFractionDigits</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">		String strV <span class="token operator">=</span> df<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="codeline">	spaces <span class="token operator">+=</span> <span class="token string">"     "</span><span class="token punctuation">;</span>
<span class="codeline">	dashes <span class="token operator">=</span> dashes<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> dashes<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	String s <span class="token operator">=</span> spaces <span class="token operator">+</span> strV <span class="token operator">+</span> dashes<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> dashes<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> strV<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">leftExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> s <span class="token operator">+=</span> leftTree<span class="token punctuation">.</span><span class="token function">showTreeDashes</span><span class="token punctuation">(</span>spaces<span class="token punctuation">,</span> dashes<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">rightExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> s <span class="token operator">+=</span> rightTree<span class="token punctuation">.</span><span class="token function">showTreeDashes</span><span class="token punctuation">(</span>spaces<span class="token punctuation">,</span> dashes<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="codeline">	<span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>Apesar da configuração um tanto carregada, o método possui um funcionamento bem simples. O algoritmo percorre a árvore em pré-ordem e, para cada chamda recursiva, adiciona série de espaços em branco, seguida do valor do nó no qual a chamada foi feita e uma sequência de traços que reduz seu tamanho de acordo. Existe também espaço para tratamento do tamanho dos valores exibidos, caso sejam valores numéricos.</p>
<p>Para a impressão no formato 2, usando parêntesis, temos o método <code>showTreeChain()</code>, muito mais curto, descrito abaixo:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="codeline"><span class="token keyword">public</span> String <span class="token function">showTreeChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="codeline">	String s <span class="token operator">=</span> <span class="token string">"("</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">leftExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> s <span class="token operator">+=</span> <span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">showTreeChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">rightExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> s <span class="token operator">+=</span> <span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">showTreeChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="codeline">	<span class="token keyword">return</span> s<span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">;</span>
<span class="codeline"><span class="token punctuation">}</span>
</code></pre>
<p>O método <code>showTreeChain()</code> apresenta de modo muito mais óbvio o percurso em pre-ordem que é desenvolvido nele. De fato, tanto esse método quanto o anterior (<code>showTreeDashes</code>) têm sua complexidade dominada pelo percurso, sendo portanto lineares.</p>
<h1 id="conclusao">Conclusão</h1>
<p>
	Com isso, finalizamos a implementação da classe <code>BinaryTree<T></code>. Enfatizamos que o desenvolvimento deste projeto foi concluido com êxito e proporcionou valiosas experiências e aprendizado para os alunos autores do presente documento. Agradecemos ao docente organizador pela oportunidade. 
</p> <span style="color: white"> Beijos. :D </span>
    </div>

  </div>


</body>

</html>
